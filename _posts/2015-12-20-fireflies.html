---
layout: default
title: Fireflies
---
<p>I like photography with color way more than black and white, but I like my Processing sketches in monotone. But here's some color.</p>
	<canvas data-src="/sketches/connect/connect.pde /sketches/connect/Connector.pde /sketches/connect/Particle.pde"></canvas>
	
	<pre class="code">
Particle[] particles = new Particle[1500];
Connector[] c = new Connector[6];

float elapsedFrames, d, limit;
PVector loc, vel, mouse, mouse_, direction;
PVector cloc, rand;

void setup()
{
  size(800,600);
  
  for (int i=0; i<particles.length; i++)
  {
    loc = new PVector(random(0,width), random(0,height));
    vel = new PVector(0,0);
    particles[i] = new Particle(loc, vel);
  }
  
  for (int m=0; m<c.length;m++)
  {
    rand = new PVector(random(width), random(height));
    c[m] = new Connector(rand);
  }
}

void draw()
{
  background(#020122);
  
  elapsedFrames++;
  mouse = new PVector(mouseX, mouseY);
  for (int n=0; n<c.length; n++)
  {
    c[n].update(mouse);
    c[n].run();
  }
}


class Connector{
  PVector c_loc;
  PVector c_loc_;
  PVector initloc;
  PVector interact;
  float pushforce, recoverforce;

  
  Connector(PVector _c_loc)
  {
    float deg = random(360);
    float r = random(10,300);
    initloc = _c_loc;
    c_loc = initloc;
    
    pushforce = 300;
    recoverforce = 30;
  }
  
  void update(PVector _target)
  {
    PVector loc0 = c_loc;
    interact = _target;
    PVector ab = PVector.sub(interact, loc0);
    float r = pushforce/(ab.x*ab.x+ab.y*ab.y);
    PVector go = new PVector(c_loc.x-ab.x*r, c_loc.y-ab.y*r);
    PVector pull = new PVector(((initloc.x-loc0.x)/recoverforce), ((initloc.y-loc0.y)/recoverforce));
    c_loc = PVector.add(go, pull);
  }
  
  void bounds()
  {
    if(c_loc.y > height || c_loc.y < 0 || c_loc.x > width || c_loc.x < 0){
      c_loc.x = random(width);
      c_loc.y = random(height);
    }
  }
  
  void display()
  {
    limit = 80;

    for (int j=0; j<particles.length; j++)
    {
      particles[j].run();
      d = particles[j].getDistance(c_loc.x, c_loc.y);
      PVector posNow = particles[j].getPosition();
      if (d<limit)
      {
        stroke(#f8fa90);
        strokeWeight(.5);
        line(posNow.x, posNow.y, c_loc.x, c_loc.y);
      }    
    }

  }
  
  void run()
  {
    bounds();
    display();
  }
}

class Particle{
  PVector pos, vel, noiseVec;
  float noiseFloat;
  boolean out;
  float distance;
  int index;
  color c;

  
  Particle(PVector _pos, PVector _vel)
  {
    pos = _pos;
    vel = _vel;
    noiseVec = new PVector();
    
    color[] choices = {#7C898B, #636564, #474044, #4f5165};
    index = int(random(choices.length)-1);
    c = choices[index];
  }
  
  void update()
  {
    noiseFloat = noise(pos.x * 0.005, pos.y * 0.005, elapsedFrames * 0.005);
    noiseVec.x = -cos((noiseFloat * TWO_PI));
    noiseVec.y = sin((noiseFloat * TWO_PI));

    vel.add(noiseVec);
    vel.div(2.5);
    pos.add(vel);
  }
  
  void display()
  {
    fill(c,55);
    noStroke();
    ellipse(pos.x, pos.y, 3, 3);
  }
  
  void bounds()
  {
    if(pos.y > height || pos.y < 0 || pos.x > width || pos.x < 0){
      pos.x = 0;
      pos.y = random(height);
    }
  }

  void run()
  {
    update();
    bounds();
    display();
  }  
  
  PVector getPosition()
  {
    return pos;
  }
  
  float getDistance(float tx, float ty)
  {
    PVector target = new PVector(tx, ty);
    PVector dir = PVector.sub(pos, target);
    distance = dir.mag();
    return distance;
  }
}

	</pre>